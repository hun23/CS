# 프로세스 관리
## 프로세스 생성
- 부모 프로세스가 자식 프로세스 생성
  - 운영체제에 시스템 콜을 보내서 생성
  - fork()
- 프로세스의 트리(계층 구조) 형성
- 프로세스는 자원을 필요로 함
  - 운영체제로부터 받는다 / 부모와 공유한다
- 자원의 공유
  - 부모와 자식이 모든 자원을 공유하는 모델
  - 일부를 공유하는 모델
  - 전혀 공유하지 않는 모델
- 수행(Execution)
  - 부모와 자식은 공존하며 수행되는 모델
  - 자식이 종료(terminate)될 때 까지 부모가 기다리는(wait)모델
## 프로세스와 관련한 시스템 콜
### fork()
- 주소 공간(Address space)
  - 자식은 부모의 공간을 복사함(binary and OS data)
  - 자식은 그 공간에 새로운 프로그램을 올림
  - `fork()` 시스템 콜이 새로운 프로세스를 생성
  - 부모를 그대로 복사(OS data except pID + binary)
  - 주소 공간 할당
### exec()
- `fork()` 후 이어지는 exec() 시스템 콜(예시: `execlp()`)을 통해 새로운 프로그램을 메모리에 올린다
  - 복사된 프로세스에 원하는 프로세스를 덮어쓰는 것
  - 따라서 `execlp()`아래의 코드를 실행되지 않음
### wait()
- `wait()` 시스템 콜
  - 프로세스 A가 `wait()` 시스템 콜을 호출하면
  - 커널은 child가 종료될 때까지 프로세스 A를 sleep시킨다(block)
  - child process가 종료되면 커널은 프로세스 A를 깨운다(ready)
  - 예시: 리눅스 터미널에서 vi를 실행시킨 경우
### exit()
- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(***exit***)
  - 자발적 종료
  - 명시하지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌
  - 자식이 부모에게 output data를 보냄(via wait)
  - 프로세스의 각종 자원들이 운영체제에게 반납됨
- 부모 프로세스가 자식의 수행을 종료시킴 (***abort***)
  - kill, break(리눅스 ctrl+c) 등을 입력한 경우
  - 자식이 할당 자원의 한계치를 넘어서거나
  - 자식에게 할당된 태스크가 더 이상 필요하지 않거나
  - 부모가 종료(exit)하는 경우
    - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않음
    - 자식을 먼저 종료하는 단계적인 종료

## 프로세스 간 협력
- 독립적 프로세스
  - 프로세세는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다
- 협력 프로세스
  - 프로세스 협력 메커니즘을 통해 프로세스 간 수행에 영향을 미칠 수 있다.
- 프로세스 간 협력 메커니즘(IPC: Interprocess Communication)
  - message passing: 커널을 통해 메시지 전달
  - shared memory: 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 것
    - thread의 경우 사실상 하나의 프로세스이므로 프로세스 간 협력은 아니지만, shared memory 방식으로 협력
    - 한 프로세스가 악성 프로세스인 경우 문제가 발생할 수 있다

### Message Passing
- 프로세스 사이에 공유 변수를 일체 사용하지 않고 통신하는 시스템
  - Direct Communication: 통신하려는 프로세스의 이름을 명시적으로 표시
  - Indirect Communication: mailbox(또는 port)를 통해 메시지를 간접 전달